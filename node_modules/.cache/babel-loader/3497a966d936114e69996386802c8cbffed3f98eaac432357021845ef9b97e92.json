{"ast":null,"code":"var clone = function () {\n  'use strict';\n\n  /**\n   * Clones (copies) an Object using deep copying.\n   *\n   * This function supports circular references by default, but if you are certain\n   * there are no circular references in your object, you can save some CPU time\n   * by calling clone(obj, false).\n   *\n   * Caution: if `circular` is false and `parent` contains circular references,\n   * your program may enter an infinite loop and crash.\n   *\n   * @param `parent` - the object to be cloned\n   * @param `circular` - set to true if the object to be cloned may contain\n   *    circular references. (optional - true by default)\n   * @param `depth` - set to a number if the object is only to be cloned to\n   *    a particular depth. (optional - defaults to Infinity)\n   * @param `prototype` - sets the prototype to be used when cloning an object.\n   *    (optional - defaults to parent prototype).\n  */\n  function clone(parent, circular, depth, prototype) {\n    var filter;\n    if (typeof circular === 'object') {\n      depth = circular.depth;\n      prototype = circular.prototype;\n      filter = circular.filter;\n      circular = circular.circular;\n    }\n    // maintain two arrays for circular references, where corresponding parents\n    // and children have the same index\n    var allParents = [];\n    var allChildren = [];\n    var useBuffer = typeof Buffer != 'undefined';\n    if (typeof circular == 'undefined') circular = true;\n    if (typeof depth == 'undefined') depth = Infinity;\n\n    // recurse this function so we don't reset allParents and allChildren\n    function _clone(parent, depth) {\n      // cloning null always returns null\n      if (parent === null) return null;\n      if (depth == 0) return parent;\n      var child;\n      var proto;\n      if (typeof parent != 'object') {\n        return parent;\n      }\n      if (clone.__isArray(parent)) {\n        child = [];\n      } else if (clone.__isRegExp(parent)) {\n        child = new RegExp(parent.source, __getRegExpFlags(parent));\n        if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n      } else if (clone.__isDate(parent)) {\n        child = new Date(parent.getTime());\n      } else if (useBuffer && Buffer.isBuffer(parent)) {\n        if (Buffer.allocUnsafe) {\n          // Node.js >= 4.5.0\n          child = Buffer.allocUnsafe(parent.length);\n        } else {\n          // Older Node.js versions\n          child = new Buffer(parent.length);\n        }\n        parent.copy(child);\n        return child;\n      } else {\n        if (typeof prototype == 'undefined') {\n          proto = Object.getPrototypeOf(parent);\n          child = Object.create(proto);\n        } else {\n          child = Object.create(prototype);\n          proto = prototype;\n        }\n      }\n      if (circular) {\n        var index = allParents.indexOf(parent);\n        if (index != -1) {\n          return allChildren[index];\n        }\n        allParents.push(parent);\n        allChildren.push(child);\n      }\n      for (var i in parent) {\n        var attrs;\n        if (proto) {\n          attrs = Object.getOwnPropertyDescriptor(proto, i);\n        }\n        if (attrs && attrs.set == null) {\n          continue;\n        }\n        child[i] = _clone(parent[i], depth - 1);\n      }\n      return child;\n    }\n    return _clone(parent, depth);\n  }\n\n  /**\n   * Simple flat clone using prototype, accepts only objects, usefull for property\n   * override on FLAT configuration object (no nested props).\n   *\n   * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n   * works.\n   */\n  clone.clonePrototype = function clonePrototype(parent) {\n    if (parent === null) return null;\n    var c = function () {};\n    c.prototype = parent;\n    return new c();\n  };\n\n  // private utility functions\n\n  function __objToStr(o) {\n    return Object.prototype.toString.call(o);\n  }\n  ;\n  clone.__objToStr = __objToStr;\n  function __isDate(o) {\n    return typeof o === 'object' && __objToStr(o) === '[object Date]';\n  }\n  ;\n  clone.__isDate = __isDate;\n  function __isArray(o) {\n    return typeof o === 'object' && __objToStr(o) === '[object Array]';\n  }\n  ;\n  clone.__isArray = __isArray;\n  function __isRegExp(o) {\n    return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n  }\n  ;\n  clone.__isRegExp = __isRegExp;\n  function __getRegExpFlags(re) {\n    var flags = '';\n    if (re.global) flags += 'g';\n    if (re.ignoreCase) flags += 'i';\n    if (re.multiline) flags += 'm';\n    return flags;\n  }\n  ;\n  clone.__getRegExpFlags = __getRegExpFlags;\n  return clone;\n}();\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}","map":{"version":3,"names":["clone","parent","circular","depth","prototype","filter","allParents","allChildren","useBuffer","Buffer","Infinity","_clone","child","proto","__isArray","__isRegExp","RegExp","source","__getRegExpFlags","lastIndex","__isDate","Date","getTime","isBuffer","allocUnsafe","length","copy","Object","getPrototypeOf","create","index","indexOf","push","i","attrs","getOwnPropertyDescriptor","set","clonePrototype","c","__objToStr","o","toString","call","re","flags","global","ignoreCase","multiline","module","exports"],"sources":["/workspaces/AshTerm/node_modules/clone/clone.js"],"sourcesContent":["var clone = (function() {\n'use strict';\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\nfunction clone(parent, circular, depth, prototype) {\n  var filter;\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    filter = circular.filter;\n    circular = circular.circular\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n};\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n};\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n};\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n};\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}